import os
import sys
import tkinter as tk
from tkinter import filedialog, messagebox, ttk
from datetime import datetime, timedelta
from pathlib import Path
from typing import List, Tuple, Dict, Optional, Any

# Import third-party libraries
import pandas as pd
import numpy as np
import matplotlib.pyplot as plt
from matplotlib.backends.backend_tkagg import FigureCanvasTkAgg
import customtkinter as ctk

# Set appearance mode and default color theme for CustomTkinter
ctk.set_appearance_mode("System")  # Options: "System", "Dark", "Light"
ctk.set_default_color_theme("blue")  # Options: "blue", "green", "dark-blue"

# =========================================================================
# CONSTANTS AND CONFIGURATION
# =========================================================================

"""
Report configuration dictionary with the following structure:
- cols: Columns to extract from the Excel files
- key: Columns used to identify unique records for comparison
- desc: Descriptive name shown in the UI
- header_row: Row number where headers are located (0-based)
- data_offset: Number of rows to skip after the header row before data starts
"""
REPORT_FILES = {
    "DiscordGroup": {
        "cols": ["Gamer", "Group", "Action", "Moderator", "Date"],
        "key": ["Gamer", "Group", "Action"],
        "desc": "Discord Group Assignments",
        "header_row": 0,
        "data_offset": 0
    },
    "roleGamerA": {
        "cols": ["Gamer2", "Class", "Role", "Action2", "Performed by", "Date2"],
        "key": ["Gamer2", "Class", "Role", "Action2"],
        "desc": "Role Gamer A",
        "header_row": 0,
        "data_offset": 0
    },
    "roleGamer": {
        "cols": ["Gamer Login", "First Gamertag", "Last Gamertag", "Email", "Role2", "Granted by"],
        "key": ["Gamer Login", "Role2"],
        "desc": "Role Gamer",
        "header_row": 0,
        "data_offset": 0
    },
    "gamerReportA": {
        "cols": ["Gamer Name", "IP", "Access Date"],
        "key": ["Gamer Name"],
        "desc": "Gamer Report Activity",
        "header_row": 3,
        "data_offset": 1
    },
    "gamerReportB": {
        "cols": ["Gamer3", "First Gamertag3", "Last Gamertag3", "email3", "Connection", "Group3"],
        "key": ["Gamer3", "Group3"],
        "desc": "Gamer Report Info",
        "header_row": 0,
        "data_offset": 0
    },
}

# Theme and styling colors
COLORS = {
    "primary": "#1a5276",       # Dark blue for primary elements
    "secondary": "#2980b9",     # Lighter blue for secondary elements
    "accent": "#f39c12",        # Orange for accent/highlight
    "warning": "#f1c40f",       # Yellow for warnings (15-30 day inactivity)
    "danger": "#e74c3c",        # Red for danger (>30 day inactivity)
    "success": "#2ecc71",       # Green for positive indicators
    "light": "#ecf0f1",         # Light gray for backgrounds
    "dark": "#2c3e50",          # Dark slate for text
    "gray": "#95a5a6",          # Medium gray for inactive elements
    "white": "#ffffff",         # White for contrast
    "black": "#000000",         # Black for text
}

# Excel reporting configuration
EXCEL_STYLES = {
    "title": {
        "bold": True,
        "font_size": 14,
        "align": "center",
        "valign": "vcenter",
        "font_color": COLORS["primary"],
    },
    "subtitle": {
        "italic": True,
        "align": "center",
        "valign": "vcenter",
        "font_color": COLORS["secondary"],
    },
    "header": {
        "bold": True,
        "text_wrap": True,
        "valign": "top",
        "fg_color": "#D7E4BC",
        "border": 1,
    },
    "warning": {
        "bg_color": COLORS["warning"],
        "font_color": "#7D6608",
    },
    "danger": {
        "bg_color": COLORS["danger"],
        "font_color": "#FFFFFF",
    },
}

# =========================================================================
# UTILITY FUNCTIONS
# =========================================================================

def find_header_row(path: Path, expected_cols: List[str], spec: Dict[str, Any], max_rows: int = 30) -> int:
    """
    Find the row containing all expected column headers, with case-insensitive matching.
    
    Args:
        path: Path to the Excel file
        expected_cols: List of expected column names
        spec: Report specification with header_row info
        max_rows: Maximum number of rows to check
        
    Returns:
        Index of the header row (0-based)
        
    Raises:
        ValueError: If header row not found
    """
    # If header_row is specified in the spec, use that directly
    if "header_row" in spec:
        return spec["header_row"]
    
    # Otherwise, perform dynamic header detection
    try:
        df = pd.read_excel(path, header=None, nrows=max_rows)
        
        # Normalize column names for comparison
        expected_lower = [col.lower().strip() for col in expected_cols]
        
        for idx, row in df.iterrows():
            # Convert all values to strings for case-insensitive comparison
            row_values = [str(val).lower().strip() if not pd.isna(val) else "" for val in row]
            
            # Check if all expected columns are in this row (partial match)
            if all(any(exp in val for val in row_values) for exp in expected_lower):
                return idx
    except Exception as e:
        raise ValueError(f"Error reading {path}: {str(e)}")
            
    raise ValueError(f"Header with columns {expected_cols} not found in {path}")


def load_report(path: Path, spec: Dict[str, Any]) -> pd.DataFrame:
    """
    Load an Excel report with flexible header detection and data cleaning.
    
    Args:
        path: Path to the Excel file
        spec: Report specification with expected columns
        
    Returns:
        DataFrame containing the report data with standardized columns
        
    Raises:
        ValueError: If file cannot be processed
    """
    try:
        # Get header row from specification
        header_row = spec["header_row"]
        data_offset = spec.get("data_offset", 0)
        
        # Read Excel with specified header row
        df = pd.read_excel(path, header=header_row, skiprows=range(header_row+1, header_row+1+data_offset))
        
        # Perform case-insensitive column mapping
        col_mapping = {}
        for expected_col in spec["cols"]:
            for col in df.columns:
                if expected_col.lower().strip() == str(col).lower().strip():
                    col_mapping[col] = expected_col
                    break
        
        # Rename columns to expected case
        df = df.rename(columns=col_mapping)
        
        # Ensure all expected columns exist
        missing_cols = set(spec["cols"]) - set(df.columns)
        if missing_cols:
            raise ValueError(f"Missing columns in {path}: {missing_cols}")
            
        # Clean up data - convert numeric stored as text
        for col in df.columns:
            # Try to convert numerical columns stored as text
            if df[col].dtype == 'object':
                try:
                    # Check if column has numeric values stored as text
                    numeric_check = pd.to_numeric(df[col], errors='coerce')
                    # If >50% of values convert to numbers, convert the column
                    if numeric_check.notna().sum() > 0.5 * len(df):
                        df[col] = numeric_check
                except:
                    pass
                    
        # Standardize date columns
        for col in df.columns:
            if 'date' in col.lower() or 'time' in col.lower():
                try:
                    df[col] = pd.to_datetime(df[col], errors='coerce')
                except:
                    pass
        
        return df[spec["cols"]]
    except Exception as e:
        raise ValueError(f"Error processing {path}: {str(e)}")


def merge_diff(prev: pd.DataFrame, curr: pd.DataFrame, key: List[str]) -> Tuple[pd.DataFrame, pd.DataFrame]:
    """
    Compare two DataFrames and identify added and removed rows based on key columns.
    
    Args:
        prev: Previous day's data
        curr: Current day's data
        key: List of columns that identify unique records
        
    Returns:
        Tuple of (added, removed) DataFrames
    """
    # Create a stable string representation of values for comparison
    prev_comp = prev.copy()
    curr_comp = curr.copy()
    
    for df in [prev_comp, curr_comp]:
        for col in df.columns:
            if df[col].dtype != 'object':
                df[col] = df[col].astype(str)
    
    # Create composite keys for comparison
    prev_comp['_comp_key'] = prev_comp[key].apply(lambda row: '|'.join(row.values.astype(str)), axis=1)
    curr_comp['_comp_key'] = curr_comp[key].apply(lambda row: '|'.join(row.values.astype(str)), axis=1)
    
    # Identify added and removed records
    prev_keys = set(prev_comp['_comp_key'])
    curr_keys = set(curr_comp['_comp_key'])
    
    added_keys = curr_keys - prev_keys
    removed_keys = prev_keys - curr_keys
    
    # Extract added and removed records
    added = curr[curr_comp['_comp_key'].isin(added_keys)]
    removed = prev[prev_comp['_comp_key'].isin(removed_keys)]
    
    return added, removed


def format_excel(writer, sheet_name, df):
    """
    Apply professional formatting to an Excel worksheet.
    
    Args:
        writer: Excel writer object
        sheet_name: Name of the worksheet
        df: DataFrame with the data
    """
    workbook = writer.book
    worksheet = writer.sheets[sheet_name]
    
    # Define formats
    header_format = workbook.add_format(EXCEL_STYLES["header"])
    warning_format = workbook.add_format(EXCEL_STYLES["warning"])
    danger_format = workbook.add_format(EXCEL_STYLES["danger"])
    
    # Write header with format
    for col_num, value in enumerate(df.columns.values):
        worksheet.write(0, col_num, value, header_format)
    
    # Set column widths
    for i, col in enumerate(df.columns):
        max_len = max(
            df[col].astype(str).map(len).max(),
            len(str(col))
        ) + 2
        max_len = min(max_len, 50)  # Cap width at 50 characters
        worksheet.set_column(i, i, max_len)
    
    # Apply conditional formatting for specific sheets
    if 'inactive' in sheet_name.lower():
        days_col = df.columns.get_loc('DaysSince') if 'DaysSince' in df.columns else None
        if days_col is not None:
            # Apply warning format (15-30 days)
            worksheet.conditional_format(1, days_col, len(df)+1, days_col, {
                'type': 'cell',
                'criteria': 'between',
                'minimum': 15,
                'maximum': 30,
                'format': warning_format
            })
            
            # Apply danger format (>30 days)
            worksheet.conditional_format(1, days_col, len(df)+1, days_col, {
                'type': 'cell',
                'criteria': '>',
                'value': 30,
                'format': danger_format
            })
    
    # Add alternating row colors for readability
    worksheet.conditional_format(1, 0, len(df), len(df.columns)-1, {
        'type': 'formula',
        'criteria': '=MOD(ROW(),2)=0',
        'format': workbook.add_format({'bg_color': '#F8F8F8'})
    })

# =========================================================================
# CORE ANALYZER CLASS
# =========================================================================

class GameGroupAnalyser:
    """
    Core class that handles the analysis of game group report files.
    
    This class:
    1. Locates the latest two day folders to compare
    2. Loads and processes report files
    3. Identifies changes between days
    4. Analyzes user inactivity
    5. Exports results to Excel
    """
    
    def __init__(self, root_folder: Path):
        """
        Initialize the analyzer with the root folder containing the data structure.
        
        Args:
            root_folder: Path to the root folder with Year/Month/Day structure
        """
        self.root = root_folder
        self.today_path, self.yesterday_path = self._locate_latest_dates()
        self.results: Dict[str, Dict[str, pd.DataFrame]] = {}
        self.stats: Dict[str, Dict[str, int]] = {}

    def _locate_latest_dates(self) -> Tuple[Path, Path]:
        """
        Find the latest two day folders in the Year/Month/Day structure.
        
        Returns:
            Tuple of (today_path, yesterday_path)
            
        Raises:
            RuntimeError: If not enough data folders found
        """
        dates = []
        
        # Traverse the year/month/day folder structure
        for year_dir in self.root.iterdir():
            if not year_dir.is_dir() or not year_dir.name.isdigit():
                continue
                
            for month_dir in year_dir.iterdir():
                if not month_dir.is_dir() or len(month_dir.name) != 2:
                    continue
                    
                for day_dir in month_dir.iterdir():
                    if not day_dir.is_dir() or len(day_dir.name) != 2:
                        continue
                        
                    try:
                        dt = datetime(int(year_dir.name), int(month_dir.name), int(day_dir.name))
                        dates.append((dt, day_dir))
                    except ValueError:
                        pass
        
        # Sort by date
        dates.sort(key=lambda x: x[0])
        
        if len(dates) < 2:
            raise RuntimeError("Need at least two daily folders to compare.")
        
        today, yesterday = dates[-1][1], dates[-2][1]
        print(f"Comparing {today} (today) with {yesterday} (yesterday)")
        return today, yesterday

    def analyse(self):
        """
        Analyze all report types by comparing the latest two days.
        
        This method processes each report type, identifying changes and updating statistics.
        For gamerReportA, it calls a special method to analyze user inactivity.
        """
        for r_name, spec in REPORT_FILES.items():
            # Initialize statistics for this report
            self.stats[r_name] = {
                "added": 0, 
                "removed": 0, 
                "inactive_15": 0, 
                "inactive_30": 0
            }
            
            # Special handling for gamer report A (inactivity)
            if r_name == "gamerReportA":
                self._analyse_inactivity(r_name, spec)
                continue
                
            # Standard comparison analysis for other reports
            prev_file = self.yesterday_path / f"{r_name}.xlsx"
            curr_file = self.today_path / f"{r_name}.xlsx"
            
            if not (prev_file.exists() and curr_file.exists()):
                print(f"Skipping {r_name}: files not found")
                continue
                
            try:
                # Load reports with standardized columns
                prev_df = load_report(prev_file, spec)
                curr_df = load_report(curr_file, spec)
                
                # Add timestamps for reference
                prev_timestamp = self._get_folder_date(self.yesterday_path)
                curr_timestamp = self._get_folder_date(self.today_path)
                
                prev_df['Report Date'] = prev_timestamp
                curr_df['Report Date'] = curr_timestamp
                
                # Find differences between the two days
                added, removed = merge_diff(prev_df, curr_df, spec["key"])
                
                # Store results
                self.results[r_name] = {
                    "added": added,
                    "removed": removed,
                }
                
                # Update statistics
                self.stats[r_name]["added"] = len(added)
                self.stats[r_name]["removed"] = len(removed)
                
                print(f"{r_name}: {len(added)} added, {len(removed)} removed")
                
            except Exception as e:
                print(f"Error analyzing {r_name}: {e}")
                messagebox.showwarning("Analysis Warning", f"Error analyzing {r_name}: {e}")

    def _get_folder_date(self, folder_path: Path) -> str:
        """
        Extract date from folder path in YYYY-MM-DD format.
        
        Args:
            folder_path: Path to day folder
            
        Returns:
            Formatted date string
        """
        parts = list(folder_path.parts)
        if len(parts) >= 3:
            try:
                year = parts[-3]
                month = parts[-2]
                day = parts[-1]
                return f"{year}-{month}-{day}"
            except:
                pass
        return datetime.now().strftime("%Y-%m-%d")

    def _analyse_inactivity(self, r_name: str, spec: Dict[str, Any]):
        """
        Analyze user inactivity in the gamerReportA.
        
        This method:
        1. Loads the current gamerReportA
        2. Identifies users who haven't accessed videos recently
        3. Categorizes them into warning (15-30 days) and danger (>30 days) groups
        
        Args:
            r_name: Report name
            spec: Report specification
        """
        file_path = self.today_path / f"{r_name}.xlsx"
        if not file_path.exists():
            print(f"Skipping {r_name}: file not found")
            return
            
        try:
            df = load_report(file_path, spec)
            
            # Convert to datetime if not already
            date_col = "Access Date"
            if date_col in df.columns:
                df[date_col] = pd.to_datetime(df[date_col], errors='coerce')
                
                # Group by user and find last access date (should already be grouped)
                # In case there are multiple entries per user, take the most recent
                last_seen = df.groupby("Gamer Name")[date_col].max().reset_index()
                
                # Calculate days since last access
                current_date = datetime.now()
                last_seen["DaysSince"] = (current_date - last_seen[date_col]).dt.days
                
                # Categorize based on inactivity thresholds
                yellow = last_seen[(last_seen["DaysSince"] > 15) & (last_seen["DaysSince"] <= 30)]
                red = last_seen[last_seen["DaysSince"] > 30]
                
                # Store results
                self.results[r_name] = {
                    "inactive_15": yellow,
                    "inactive_30": red,
                }
                
                # Update statistics
                self.stats[r_name]["inactive_15"] = len(yellow)
                self.stats[r_name]["inactive_30"] = len(red)
                
                print(f"{r_name}: {len(yellow)} users inactive >15 days, {len(red)} users inactive >30 days")
            else:
                print(f"Warning: Date column '{date_col}' not found in {r_name}")
                
        except Exception as e:
            print(f"Error analyzing inactivity for {r_name}: {e}")
            messagebox.showwarning("Analysis Warning", f"Error analyzing inactivity for {r_name}: {e}")

    def export_summary(self, out_path: Path) -> bool:
        """
        Export all results to a professionally formatted Excel file.
        
        Args:
            out_path: Path to save the Excel file
            
        Returns:
            True if export was successful, False otherwise
        """
        try:
            with pd.ExcelWriter(out_path, engine="xlsxwriter") as writer:
                # Create a summary sheet first
                self._create_summary_sheet(writer)
                
                # Then export detailed results
                for r_name, detail in self.results.items():
                    for sub_name, df in detail.items():
                        if df.empty:
                            continue
                            
                        # Create a valid sheet name (Excel limits sheet names to 31 chars)
                        sheet = f"{r_name}_{sub_name}"[:31]
                        
                        # Export data
                        df.to_excel(writer, sheet_name=sheet, index=False)
                        
                        # Apply formatting
                        format_excel(writer, sheet, df)
                        
            return True
        except Exception as e:
            print(f"Error exporting summary: {e}")
            messagebox.showerror("Export Error", f"Failed to export summary: {e}")
            return False

    def _create_summary_sheet(self, writer):
        """
        Create a summary sheet with key metrics and beautiful formatting.
        
        Args:
            writer: Excel writer object
        """
        summary_data = []
        
        # Gather summary data for each report type
        for r_name, spec in REPORT_FILES.items():
            stats = self.stats.get(r_name, {})
            
            row = {
                'Report': r_name,
                'Description': spec.get('desc', r_name),
                'Added': stats.get('added', 0),
                'Removed': stats.get('removed', 0),
                'Inactive (15-30d)': stats.get('inactive_15', 0),
                'Inactive (>30d)': stats.get('inactive_30', 0),
            }
            summary_data.append(row)
            
        # Create DataFrame
        summary_df = pd.DataFrame(summary_data)
        
        # Add timestamp and date range
        timestamp = datetime.now().strftime("%Y-%m-%d %H:%M:%S")
        date_range = (
            f"Comparing: {self._get_folder_date(self.today_path)} vs "
            f"{self._get_folder_date(self.yesterday_path)}"
        )
        
        # Export to Excel
        summary_df.to_excel(writer, sheet_name='Summary', index=False, startrow=3)
        
        # Get worksheet object
        worksheet = writer.sheets['Summary']
        workbook = writer.book
        
        # Define formats
        title_format = workbook.add_format(EXCEL_STYLES["title"])
        subtitle_format = workbook.add_format(EXCEL_STYLES["subtitle"])
        header_format = workbook.add_format(EXCEL_STYLES["header"])
        
        # Write title and timestamp
        worksheet.merge_range('A1:F1', 'Game Group Daily Tracker - Summary', title_format)
        worksheet.merge_range('A2:F2', date_range, subtitle_format)
        worksheet.merge_range('A3:F3', f'Generated: {timestamp}', subtitle_format)
        
        # Format header
        for col_num, value in enumerate(summary_df.columns.values):
            worksheet.write(3, col_num, value, header_format)
            
        # Set column widths
        worksheet.set_column('A:A', 18)  # Report
        worksheet.set_column('B:B', 30)  # Description
        worksheet.set_column('C:F', 15)  # Metrics
        
        # Add conditional formatting for metrics
        for col in ['C', 'D', 'E', 'F']:  # Added, Removed, Inactive columns
            worksheet.conditional_format(f'{col}5:{col}{len(summary_data)+4}', {
                'type': '3_color_scale',
                'min_color': '#FFFFFF',
                'mid_color': '#FFEB9C',
                'max_color': '#FFC7CE',
            })

# =========================================================================
# CHART GENERATOR CLASS
# =========================================================================

class ChartGenerator:
    """
    Creates data visualizations for the dashboard.
    
    This class handles the generation of charts to visualize:
    1. Changes in report data (added/removed)
    2. User inactivity statistics
    """
    
    def __init__(self, analyser: GameGroupAnalyser):
        """
        Initialize with reference to the analyser.
        
        Args:
            analyser: The GameGroupAnalyser with results to visualize
        """
        self.analyser = analyser
        
        # Set matplotlib style for consistent, professional appearance
        plt.style.use('ggplot')
        
    def create_summary_bar_chart(self, frame):
        """
        Create a bar chart showing added/removed counts for each report type.
        
        Args:
            frame: The tkinter frame to add the chart to
            
        Returns:
            Canvas object or None if no data
        """
        # Prepare data
        reports = []
        added = []
        removed = []
        
        for r_name, stats in self.analyser.stats.items():
            if stats.get('added', 0) > 0 or stats.get('removed', 0) > 0:
                reports.append(REPORT_FILES.get(r_name, {}).get('desc', r_name))
                added.append(stats.get('added', 0))
                removed.append(stats.get('removed', 0))
                
        if not reports:  # No data
            ctk.CTkLabel(frame, text="No changes detected", font=("Segoe UI", 12)).pack(pady=50)
            return None
            
        # Create figure and axis
        fig, ax = plt.subplots(figsize=(8, 5), dpi=100)
        
        # Set position of bars on X axis
        x = np.arange(len(reports))
        width = 0.35
        
        # Create bars with professional colors
        ax.bar(x - width/2, added, width, label='Added', color=COLORS['success'])
        ax.bar(x + width/2, removed, width, label='Removed', color=COLORS['danger'])
        
        # Add labels, title and legend
        ax.set_xlabel('Report Type', fontsize=10)
        ax.set_ylabel('Count', fontsize=10)
        ax.set_title('Changes Summary', fontsize=12, fontweight='bold', color=COLORS['primary'])
        ax.set_xticks(x)
        ax.set_xticklabels(reports, rotation=45, ha='right', fontsize=9)
        ax.legend(loc='best')
        
        # Add grid for readability
        ax.grid(True, linestyle='--', alpha=0.7)
        
        # Add values on top of bars
        for i, v in enumerate(added):
            if v > 0:
                ax.text(i - width/2, v + 0.5, str(v), ha='center', fontsize=9)
                
        for i, v in enumerate(removed):
            if v > 0:
                ax.text(i + width/2, v + 0.5, str(v), ha='center', fontsize=9)
        
        # Layout
        plt.tight_layout()
        
        # Create canvas
        canvas = FigureCanvasTkAgg(fig, master=frame)
        canvas.draw()
        canvas.get_tk_widget().pack(fill=tk.BOTH, expand=True)
        
        return canvas
        
    def create_inactivity_pie_chart(self, frame):
        """
        Create a pie chart showing user inactivity statistics.
        
        Args:
            frame: The tkinter frame to add the chart to
            
        Returns:
            Canvas object or None if no data
        """
        # Get inactivity data
        stats = self.analyser.stats.get('gamerReportA', {})
        inactive_15 = stats.get('inactive_15', 0)
        inactive_30 = stats.get('inactive_30', 0)
        
        # Only create chart if we have data
        if inactive_15 == 0 and inactive_30 == 0:
            ctk.CTkLabel(frame, text="No inactive users detected", font=("Segoe UI", 12)).pack(pady=50)
            return None
            
        # Create data
        labels = ['Inactive 15-30 days', 'Inactive >30 days']
        sizes = [inactive_15, inactive_30]
        colors = [COLORS['warning'], COLORS['danger']]
        explode = (0, 0.1)  # explode the 2nd slice
        
        # Create figure with crisp rendering
        fig, ax = plt.subplots(figsize=(6, 4), dpi=100)
        
        # Create pie chart
        wedges, texts, autotexts = ax.pie(
            sizes, 
            explode=explode, 
            labels=labels, 
            colors=colors, 
            autopct='%1.1f%%',
            shadow=True, 
            startangle=90, 
            textprops={'fontsize': 9}
        )
        
        # Enhance text visibility
        for autotext in autotexts:
            autotext.set_color('white')
            autotext.set_fontsize(9)
            autotext.set_fontweight('bold')
        
        # Equal aspect ratio ensures that pie is drawn as a circle
        ax.axis('equal')
        ax.set_title('User Inactivity', fontsize=12, fontweight='bold', color=COLORS['primary'])
        
        # Add total count as annotation
        total = inactive_15 + inactive_30
        ax.annotate(f'Total Inactive: {total}', 
                   xy=(0.5, 0.05), 
                   xycoords='figure fraction',
                   ha='center',
                   fontsize=10,
                   bbox=dict(boxstyle="round,pad=0.3", fc=COLORS['light'], ec=COLORS['gray']))
        
        # Create canvas
        canvas = FigureCanvasTkAgg(fig, master=frame)
        canvas.draw()
        canvas.get_tk_widget().pack(fill=tk.BOTH, expand=True)
        
        return canvas
        
    def create_stacked_bar_chart(self, frame):
        """
        Create a stacked bar chart summarizing all metrics.
        
        Args:
            frame: The tkinter frame to add the chart to
            
        Returns:
            Canvas object or None if no data
        """
        # Prepare data
        reports = []
        added_vals = []
        removed_vals = []
        inactive_15_vals = []
        inactive_30_vals = []
        
        for r_name, stats in self.analyser.stats.items():
            reports.append(REPORT_FILES.get(r_name, {}).get('desc', r_name))
            added_vals.append(stats.get('added', 0))
            removed_vals.append(stats.get('removed', 0))
            inactive_15_vals.append(stats.get('inactive_15', 0)),
            inactive_30_vals.append(stats.get('inactive_30', 0))
        
        if not any(added_vals + removed_vals + inactive_15_vals + inactive_30_vals):
            ctk.CTkLabel(frame, text="No data to display", font=("Segoe UI", 12)).pack(pady=50)
            return None
        
        # Create figure and axis
        fig, ax = plt.subplots(figsize=(10, 6), dpi=100)
        
        # Create stacked bars
        x = np.arange(len(reports))
        width = 0.6
        
        ax.bar(x, added_vals, width, label='Added', color=COLORS['success'])
        ax.bar(x, removed_vals, width, bottom=added_vals, label='Removed', color=COLORS['danger'])
        
        inactive_bottom = [a + r for a, r in zip(added_vals, removed_vals)]
        ax.bar(x, inactive_15_vals, width, bottom=inactive_bottom, label='Inactive 15-30d', color=COLORS['warning'])
        
        inactive_15_bottom = [a + b + c for a, b, c in zip(added_vals, removed_vals, inactive_15_vals)]
        ax.bar(x, inactive_30_vals, width, bottom=inactive_15_bottom, label='Inactive >30d', color=COLORS['danger'])
        
        # Add labels and styling
        ax.set_xlabel('Report Type', fontsize=10)
        ax.set_ylabel('Count', fontsize=10)
        ax.set_title('All Metrics Summary', fontsize=12, fontweight='bold', color=COLORS['primary'])
        ax.set_xticks(x)
        ax.set_xticklabels(reports, rotation=45, ha='right', fontsize=9)
        ax.legend(loc='best')
        
        # Add grid for readability
        ax.grid(True, linestyle='--', alpha=0.7)
        
        # Layout
        plt.tight_layout()
        
        # Create canvas
        canvas = FigureCanvasTkAgg(fig, master=frame)
        canvas.draw()
        canvas.get_tk_widget().pack(fill=tk.BOTH, expand=True)
        
        return canvas

# =========================================================================
# DASHBOARD UI CLASS
# =========================================================================

class Dashboard(ctk.CTk):
    """
    Main application window with a modern UI for the Game Group Tracker.
    
    Features:
    1. File selection for data root folder
    2. Analysis execution and result viewing
    3. Interactive dashboard with charts
    4. Detailed results with filtering
    5. Export functionality for reports
    """
    
    def __init__(self):
        """Initialize the Dashboard application with CustomTkinter."""
        super().__init__()
        self.title("Game Group Daily Tracker")
        self.geometry("1280x800")
        self.minsize(900, 600)
        
        # State variables
        self.analyser: Optional[GameGroupAnalyser] = None
        self.chart_gen: Optional[ChartGenerator] = None
        self.summary_file: Optional[Path] = None
        
        # Set app icon
        try:
            self.iconbitmap('icon.ico')  # Add an icon file if available
        except:
            pass
        
        # Build UI
        self._build_ui()
        
        # Configure default path from last run if exists
        self._load_config()
        
    def _build_ui(self):
        """Build the main user interface components with CustomTkinter."""
        # Configure grid
        self.grid_columnconfigure(0, weight=1)
        self.grid_rowconfigure(1, weight=1)
        
        # Header with application title and theme switch
        header_frame = ctk.CTkFrame(self)
        header_frame.grid(row=0, column=0, padx=10, pady=(10, 0), sticky="ew")
        header_frame.grid_columnconfigure(0, weight=1)
        
        # App title
        title_label = ctk.CTkLabel(
            header_frame, 
            text="Game Group Daily Tracker",
            font=ctk.CTkFont(size=20, weight="bold")
        )
        title_label.grid(row=0, column=0, padx=10, pady=10, sticky="w")
        
        # Theme switch
        theme_frame = ctk.CTkFrame(header_frame, fg_color="transparent")
        theme_frame.grid(row=0, column=1, padx=10, pady=10, sticky="e")
        
        ctk.CTkLabel(theme_frame, text="Appearance:").pack(side="left", padx=5)
        
        theme_options = ["System", "Light", "Dark"]
        theme_var = ctk.StringVar(value=ctk.get_appearance_mode())
        
        def change_theme(new_theme):
            ctk.set_appearance_mode(new_theme)
        
        theme_menu = ctk.CTkOptionMenu(
            theme_frame, 
            values=theme_options,
            variable=theme_var,
            command=change_theme
        )
        theme_menu.pack(side="left", padx=5)
        
        # Main content area with tabview
        self.tabview = ctk.CTkTabview(self)
        self.tabview.grid(row=1, column=0, padx=10, pady=10, sticky="nsew")
        
        # Create tabs
        self.tab_config = self.tabview.add("Configuration")
        self.tab_dashboard = self.tabview.add("Dashboard")
        self.tab_details = self.tabview.add("Detailed Results")
        self.tab_help = self.tabview.add("Help")
        
        # Set the default active tab
        self.tabview.set("Configuration")
        
        # Build tab content
        self._build_config_tab()
        self._build_dashboard_tab()
        self._build_details_tab()
        self._build_help_tab()
        
        # Status bar at the bottom
        self.status_var = ctk.StringVar(value="Ready")
        status_bar = ctk.CTkLabel(
            self, 
            textvariable=self.status_var,
            anchor="w",
            height=25,
            corner_radius=5,
            fg_color=COLORS["gray"],
            text_color=COLORS["white"]
        )
        status_bar.grid(row=2, column=0, padx=10, pady=(0, 10), sticky="ew")
    
    def _build_config_tab(self):
        """Build the configuration tab with folder selection and action buttons."""
        # Configure grid
        self.tab_config.grid_columnconfigure(0, weight=1)
        
        # Data folder section
        folder_frame = ctk.CTkFrame(self.tab_config)
        folder_frame.grid(row=0, column=0, padx=20, pady=20, sticky="ew")
        folder_frame.grid_columnconfigure(1, weight=1)
        
        # Section title
        ctk.CTkLabel(
            folder_frame, 
            text="Data Location",
            font=ctk.CTkFont(size=14, weight="bold")
        ).grid(row=0, column=0, columnspan=3, padx=10, pady=(10, 5), sticky="w")
        
        # Description
        ctk.CTkLabel(
            folder_frame,
            text="Select the root folder containing the year/month/day structure with daily report files.",
            text_color=COLORS["gray"]
        ).grid(row=1, column=0, columnspan=3, padx=10, pady=(0, 10), sticky="w")
        
        # Folder selection
        ctk.CTkLabel(
            folder_frame, 
            text="Root folder:"
        ).grid(row=2, column=0, padx=10, pady=10, sticky="w")
        
        self.folder_var = ctk.StringVar()
        folder_entry = ctk.CTkEntry(
            folder_frame,
            textvariable=self.folder_var,
            width=400
        )
        folder_entry.grid(row=2, column=1, padx=10, pady=10, sticky="ew")
        
        browse_btn = ctk.CTkButton(
            folder_frame,
            text="Browse",
            command=self._browse,
            width=100
        )
        browse_btn.grid(row=2, column=2, padx=10, pady=10, sticky="e")
        
        # Action buttons section
        actions_frame = ctk.CTkFrame(self.tab_config)
        actions_frame.grid(row=1, column=0, padx=20, pady=20, sticky="ew")
        
        # Action buttons with icons
        run_button = ctk.CTkButton(
            actions_frame,
            text="Run Analysis",
            command=self._run,
            font=ctk.CTkFont(size=14),
            height=40,
            fg_color=COLORS["primary"],
            hover_color=COLORS["secondary"]
        )
        run_button.pack(side="left", padx=20, pady=20)
        
        export_button = ctk.CTkButton(
            actions_frame,
            text="Export Results",
            command=self._export,
            font=ctk.CTkFont(size=14),
            height=40,
            fg_color=COLORS["accent"],
            hover_color="#e67e22",  # Darker orange
            text_color=COLORS["dark"]
        )
        export_button.pack(side="left", padx=20, pady=20)
        
        self.view_button = ctk.CTkButton(
            actions_frame,
            text="View Last Export",
            command=self._view_export,
            font=ctk.CTkFont(size=14),
            height=40,
            fg_color=COLORS["gray"],
            hover_color="#7f8c8d",  # Darker gray
            state="disabled"
        )
        self.view_button.pack(side="left", padx=20, pady=20)
        
    def _build_dashboard_tab(self):
        """Build the dashboard tab with charts and statistics."""
        # Configure grid
        self.tab_dashboard.grid_columnconfigure(0, weight=1)
        self.tab_dashboard.grid_rowconfigure(1, weight=1)
        
        # Dashboard header
        header_frame = ctk.CTkFrame(self.tab_dashboard)
        header_frame.grid(row=0, column=0, padx=20, pady=(20, 10), sticky="ew")
        
        ctk.CTkLabel(
            header_frame,
            text="Dashboard Overview",
            font=ctk.CTkFont(size=16, weight="bold")
        ).pack(side="left", padx=10, pady=10)
        
        self.refresh_btn = ctk.CTkButton(
            header_frame,
            text="Refresh Charts",
            command=self._update_charts,
            width=120
        )
        self.refresh_btn.pack(side="right", padx=10, pady=10)
        
        # Charts container
        self.charts_frame = ctk.CTkFrame(self.tab_dashboard)
        self.charts_frame.grid(row=1, column=0, padx=20, pady=10, sticky="nsew")
        self.charts_frame.grid_columnconfigure((0, 1), weight=1)
        self.charts_frame.grid_rowconfigure((0, 1), weight=1)
        
        # Chart placeholders
        self.chart_frames = {}
        
        # Top left: Changes summary
        self.chart_frames["changes"] = ctk.CTkFrame(self.charts_frame)
        self.chart_frames["changes"].grid(row=0, column=0, padx=10, pady=10, sticky="nsew")
        
        changes_header = ctk.CTkFrame(self.chart_frames["changes"], fg_color="transparent")
        changes_header.pack(fill="x", padx=10, pady=5)
        
        ctk.CTkLabel(
            changes_header,
            text="Changes Summary",
            font=ctk.CTkFont(size=14, weight="bold")
        ).pack(side="left")
        
        self.changes_content = ctk.CTkFrame(self.chart_frames["changes"], fg_color="transparent")
        self.changes_content.pack(fill="both", expand=True, padx=10, pady=5)
        
        placeholder_label = ctk.CTkLabel(
            self.changes_content,
            text="Run analysis to view changes",
            text_color=COLORS["gray"]
        )
        placeholder_label.pack(expand=True)
        
        # Top right: User inactivity
        self.chart_frames["inactivity"] = ctk.CTkFrame(self.charts_frame)
        self.chart_frames["inactivity"].grid(row=0, column=1, padx=10, pady=10, sticky="nsew")
        
        inactivity_header = ctk.CTkFrame(self.chart_frames["inactivity"], fg_color="transparent")
        inactivity_header.pack(fill="x", padx=10, pady=5)
        
        ctk.CTkLabel(
            inactivity_header,
            text="User Inactivity",
            font=ctk.CTkFont(size=14, weight="bold")
        ).pack(side="left")
        
        self.inactivity_content = ctk.CTkFrame(self.chart_frames["inactivity"], fg_color="transparent")
        self.inactivity_content.pack(fill="both", expand=True, padx=10, pady=5)
        
        placeholder_label = ctk.CTkLabel(
            self.inactivity_content,
            text="Run analysis to view inactivity data",
            text_color=COLORS["gray"]
        )
        placeholder_label.pack(expand=True)
        
        # Bottom: All metrics
        self.chart_frames["all_metrics"] = ctk.CTkFrame(self.charts_frame)
        self.chart_frames["all_metrics"].grid(row=1, column=0, columnspan=2, padx=10, pady=10, sticky="nsew")
        
        metrics_header = ctk.CTkFrame(self.chart_frames["all_metrics"], fg_color="transparent")
        metrics_header.pack(fill="x", padx=10, pady=5)
        
        ctk.CTkLabel(
            metrics_header,
            text="All Metrics Summary",
            font=ctk.CTkFont(size=14, weight="bold")
        ).pack(side="left")
        
        self.metrics_content = ctk.CTkFrame(self.chart_frames["all_metrics"], fg_color="transparent")
        self.metrics_content.pack(fill="both", expand=True, padx=10, pady=5)
        
        placeholder_label = ctk.CTkLabel(
            self.metrics_content,
            text="Run analysis to view comprehensive metrics",
            text_color=COLORS["gray"]
        )
        placeholder_label.pack(expand=True)
        
    def _build_details_tab(self):
        """Build the detailed results tab with data tables."""
        # Configure grid
        self.tab_details.grid_columnconfigure(0, weight=1)
        self.tab_details.grid_rowconfigure(1, weight=1)
        
        # Details header
        header_frame = ctk.CTkFrame(self.tab_details)
        header_frame.grid(row=0, column=0, padx=20, pady=(20, 10), sticky="ew")
        
        ctk.CTkLabel(
            header_frame,
            text="Detailed Results",
            font=ctk.CTkFont(size=16, weight="bold")
        ).pack(side="left", padx=10, pady=10)
        
        # Create a nested tabview for report types
        self.reports_tabview = ctk.CTkTabview(self.tab_details)
        self.reports_tabview.grid(row=1, column=0, padx=20, pady=10, sticky="nsew")
        
        # Placeholder label
        placeholder_frame = ctk.CTkFrame(self.reports_tabview)
        self.reports_tabview.add("No Data")
        
        ctk.CTkLabel(
            placeholder_frame,
            text="Run analysis to view detailed results",
            font=ctk.CTkFont(size=14),
            text_color=COLORS["gray"]
        ).pack(expand=True, pady=50)
        
    def _build_help_tab(self):
        """Build the help tab with documentation."""
        # Help content in a scrollable frame
        help_scroll = ctk.CTkScrollableFrame(self.tab_help, corner_radius=0)
        help_scroll.pack(fill="both", expand=True, padx=20, pady=20)
        
        # Title
        ctk.CTkLabel(
            help_scroll,
            text="Game Group Daily Tracker - Help",
            font=ctk.CTkFont(size=20, weight="bold")
        ).pack(pady=(0, 20), anchor="w")
        
        # Introduction
        ctk.CTkLabel(
            help_scroll,
            text="Introduction",
            font=ctk.CTkFont(size=16, weight="bold")
        ).pack(pady=(10, 5), anchor="w")
        
        ctk.CTkLabel(
            help_scroll,
            text="This application helps you track daily changes in game group reports by comparing the latest two days of data.",
            wraplength=800,
            justify="left"
        ).pack(pady=(0, 10), anchor="w")
        
        # Basic usage
        ctk.CTkLabel(
            help_scroll,
            text="Basic Usage",
            font=ctk.CTkFont(size=16, weight="bold")
        ).pack(pady=(10, 5), anchor="w")
        
        usage_text = """
1. Select the root folder containing your data structure (folders organized by Year/Month/Day)
2. Click "Run Analysis" to compare the latest two days
3. Review the dashboard charts and detailed results
4. Export a summary report when needed
        """
        
        ctk.CTkLabel(
            help_scroll,
            text=usage_text,
            wraplength=800,
            justify="left"
        ).pack(pady=(0, 10), anchor="w")
        
        # Report types
        ctk.CTkLabel(
            help_scroll,
            text="Report Types",
            font=ctk.CTkFont(size=16, weight="bold")
        ).pack(pady=(10, 5), anchor="w")
        
        reports_text = """
The application analyzes the following report types:

- DiscordGroup: Tracks gamers' group assignments (Columns: Gamer, Group, Action, Moderator, Date)
- roleGamerA: Monitors role assignments for gamers (Columns: Gamer2, Class, Role, Action2, Performed by, Date2) 
- roleGamer: Tracks role changes (Columns: Gamer Login, First/Last Gamertag, Email, Role2, Granted by)
- gamerReportA: Monitors user activity and inactivity (Columns: Gamer Name, IP, Access Date)
- gamerReportB: Tracks gamer account information (Columns: Gamer3, First/Last Gamertag3, email3, Connection, Group3)
        """
        
        ctk.CTkLabel(
            help_scroll,
            text=reports_text,
            wraplength=800,
            justify="left"
        ).pack(pady=(0, 10), anchor="w")
        
        # Inactivity tracking
        ctk.CTkLabel(
            help_scroll,
            text="User Inactivity Tracking",
            font=ctk.CTkFont(size=16, weight="bold")
        ).pack(pady=(10, 5), anchor="w")
        
        inactivity_text = """
The application automatically identifies users who haven't accessed recently:

- Warning (Yellow): Users inactive for 15-30 days
- Critical (Red): Users inactive for more than 30 days

This helps you proactively manage user engagement and follow up with inactive users.
        """
        
        ctk.CTkLabel(
            help_scroll,
            text=inactivity_text,
            wraplength=800,
            justify="left"
        ).pack(pady=(0, 10), anchor="w")
        
        # Data limitations
        ctk.CTkLabel(
            help_scroll,
            text="Data Limitations",
            font=ctk.CTkFont(size=16, weight="bold")
        ).pack(pady=(10, 5), anchor="w")
        
        data_text = """
Some important things to note about the data:

1. DiscordGroup, roleGamerA, and roleGamer only contain 90 days of historical data.
2. gamerReportA and gamerReportB may contain data from longer periods.
3. gamerReportA has headers in row 4 with data starting one row later.

The application is designed to handle these differences automatically.
        """
        
        ctk.CTkLabel(
            help_scroll,
            text=data_text,
            wraplength=800,
            justify="left"
        ).pack(pady=(0, 10), anchor="w")
        
        # Support section
        ctk.CTkLabel(
            help_scroll,
            text="Support",
            font=ctk.CTkFont(size=16, weight="bold")
        ).pack(pady=(10, 5), anchor="w")
        
        ctk.CTkLabel(
            help_scroll,
            text="For any issues or questions, please contact your system administrator.",
            wraplength=800,
            justify="left"
        ).pack(pady=(0, 10), anchor="w")
    
    def _browse(self):
        """Browse for data root folder."""
        path = filedialog.askdirectory(title="Select Data Root Folder")
        if path:
            self.folder_var.set(path)
            self._save_config()
    
    def _run(self):
        """Run the analysis process."""
        root_path = self.folder_var.get()
        if not root_path:
            messagebox.showerror("Error", "Please select the root folder of your reports")
            return
            
        # Update status
        self.status_var.set("Running analysis...")
        self.update_idletasks()
        
        try:
            # Run analysis
            self.analyser = GameGroupAnalyser(Path(root_path))
            self.analyser.analyse()
            
            # Create chart generator
            self.chart_gen = ChartGenerator(self.analyser)
            
            # Update UI
            self._populate_results()
            self._update_charts()
            self.status_var.set("Analysis complete")
            
            # Select dashboard tab
            self.tabview.set("Dashboard")
            
        except Exception as exc:
            self.status_var.set(f"Error: {str(exc)}")
            messagebox.showerror("Analysis Error", str(exc))
    
    def _update_charts(self):
        """Update dashboard charts."""
        if not self.chart_gen:
            return
            
        # Clear existing charts
        for frame in [self.changes_content, self.inactivity_content, self.metrics_content]:
            for widget in frame.winfo_children():
                widget.destroy()
        
        # Create charts
        self.chart_gen.create_summary_bar_chart(self.changes_content)
        self.chart_gen.create_inactivity_pie_chart(self.inactivity_content)
        self.chart_gen.create_stacked_bar_chart(self.metrics_content)
    
    def _populate_results(self):
        """Populate the results tabview with data tables."""
        # Clear existing tabs
        for tab in self.reports_tabview._tab_dict:
            if tab != "No Data":  # Keep the placeholder
                self.reports_tabview._tab_dict[tab].destroy()
        
        # Hide the placeholder
        if "No Data" in self.reports_tabview._tab_dict:
            self.reports_tabview._tab_dict["No Data"].pack_forget()
        
        if not self.analyser or not self.analyser.results:
            return
            
        # Remove the placeholder tab
        if "No Data" in self.reports_tabview._tab_dict:
            self.reports_tabview._tab_dict["No Data"].destroy()
            del self.reports_tabview._tab_dict["No Data"]
            
        # Add a tab for each report type
        for r_name, detail in self.analyser.results.items():
            # Get description for the tab name
            desc = REPORT_FILES.get(r_name, {}).get('desc', r_name)
            
            # Add the tab
            report_tab = self.reports_tabview.add(desc)
            report_tab.grid_columnconfigure(0, weight=1)
            report_tab.grid_rowconfigure(0, weight=1)
            
            # Create a nested tabview for detail types
            detail_tabview = ctk.CTkTabview(report_tab)
            detail_tabview.grid(row=0, column=0, padx=10, pady=10, sticky="nsew")
            
            # Add a tab for each detail type
            for sub_name, df in detail.items():
                if df.empty:
                    continue
                
                # Format the tab name
                detail_name = sub_name.replace('_', ' ').title()
                
                # Add the tab
                sub_tab = detail_tabview.add(detail_name)
                sub_tab.grid_columnconfigure(0, weight=1)
                sub_tab.grid_rowconfigure(1, weight=1)
                
                # Add search/filter frame
                filter_frame = ctk.CTkFrame(sub_tab)
                filter_frame.grid(row=0, column=0, padx=10, pady=(10, 5), sticky="ew")
                
                ctk.CTkLabel(filter_frame, text="Filter:").pack(side="left", padx=5, pady=5)
                filter_var = ctk.StringVar()
                filter_entry = ctk.CTkEntry(filter_frame, textvariable=filter_var, width=200)
                filter_entry.pack(side="left", padx=5, pady=5)
                
                # Create the table frame
                table_frame = ctk.CTkFrame(sub_tab)
                table_frame.grid(row=1, column=0, padx=10, pady=5, sticky="nsew")
                
                # Create a standard Tkinter Treeview for data
                columns = list(df.columns)
                tree = ttk.Treeview(table_frame, columns=columns, show="headings")
                
                # Add scrollbars
                vsb = ttk.Scrollbar(table_frame, orient="vertical", command=tree.yview)
                hsb = ttk.Scrollbar(table_frame, orient="horizontal", command=tree.xview)
                tree.configure(yscrollcommand=vsb.set, xscrollcommand=hsb.set)
                
                # Grid layout
                tree.grid(column=0, row=0, sticky="nsew")
                vsb.grid(column=1, row=0, sticky="ns")
                hsb.grid(column=0, row=1, sticky="ew")
                
                # Configure grid
                table_frame.columnconfigure(0, weight=1)
                table_frame.rowconfigure(0, weight=1)
                
                # Configure columns
                for col in columns:
                    tree.heading(col, text=col)
                    # Calculate column width
                    col_width = max(
                        df[col].astype(str).map(len).max() * 10,
                        len(str(col)) * 10
                    )
                    col_width = min(col_width, 300)  # Cap width at 300
                    tree.column(col, width=col_width, minwidth=50)
                    
                # Add data
                for i, row in df.iterrows():
                    values = [str(row[col]) for col in columns]
                    tree.insert("", "end", values=values)
                
                # Add filter buttons
                ctk.CTkButton(
                    filter_frame, 
                    text="Apply Filter",
                    command=lambda t=tree, d=df, fv=filter_var: self._apply_filter(t, d, fv.get())
                ).pack(side="left", padx=5, pady=5)
                
                ctk.CTkButton(
                    filter_frame, 
                    text="Clear Filter",
                    command=lambda t=tree, d=df, fv=filter_var: self._clear_filter(t, d, fv)
                ).pack(side="left", padx=5, pady=5)
                
                # Show record count
                count_label = ctk.CTkLabel(
                    filter_frame, 
                    text=f"Records: {len(df)}",
                    text_color=COLORS["gray"]
                )
                count_label.pack(side="right", padx=10, pady=5)
        
        # Select the first tab
        if self.reports_tabview._tab_dict:
            first_tab = list(self.reports_tabview._tab_dict.keys())[0]
            self.reports_tabview.set(first_tab)
    
    def _apply_filter(self, tree, df, filter_text):
        """Apply filter to tree view."""
        if not filter_text:
            return
            
        # Clear current tree
        for item in tree.get_children():
            tree.delete(item)
            
        # Convert to lowercase for case-insensitive search
        filter_lower = filter_text.lower()
        
        # Filter dataframe
        filtered_count = 0
        for i, row in df.iterrows():
            # Check if filter text appears in any column
            matched = any(filter_lower in str(val).lower() for val in row)
            if matched:
                values = [str(row[col]) for col in df.columns]
                tree.insert("", "end", values=values)
                filtered_count += 1
                
        # Update status with filter results
        self.status_var.set(f"Filter applied: {filtered_count} records match '{filter_text}'")
    
    def _clear_filter(self, tree, df, filter_var):
        """Clear filter and restore all data."""
        # Clear filter text
        filter_var.set("")
        
        # Clear current tree
        for item in tree.get_children():
            tree.delete(item)
            
        # Restore all data
        for i, row in df.iterrows():
            values = [str(row[col]) for col in df.columns]
            tree.insert("", "end", values=values)
            
        # Update status
        self.status_var.set(f"Filter cleared: {len(df)} records displayed")
    
    def _export(self):
        """Export analysis results to Excel."""
        if not self.analyser:
            messagebox.showerror("Error", "Run analysis first")
            return
            
        # Get export filename
        timestamp = datetime.now().strftime("%Y%m%d_%H%M%S")
        filename = f"GameGroup_Summary_{timestamp}.xlsx"
        
        file_path = filedialog.asksaveasfilename(
            title="Save Summary Report",
            defaultextension=".xlsx",
            filetypes=[("Excel files", "*.xlsx")],
            initialfile=filename
        )
        
        if not file_path:
            return
            
        # Update status
        self.status_var.set("Exporting summary...")
        self.update_idletasks()
        
# Export
        try:
            success = self.analyser.export_summary(Path(file_path))
            
            if success:
                self.summary_file = Path(file_path)
                self.view_button.configure(state="normal", fg_color=COLORS["accent"], text_color=COLORS["dark"])
                self.status_var.set(f"Summary exported to {file_path}")
                messagebox.showinfo("Export Complete", f"Summary exported to {file_path}")
            else:
                self.status_var.set("Export failed")
        except Exception as e:
            self.status_var.set(f"Export error: {str(e)}")
            messagebox.showerror("Export Error", str(e))
    
    def _view_export(self):
        """Open the last exported file."""
        if not self.summary_file or not self.summary_file.exists():
            messagebox.showerror("Error", "Export file not found")
            return
            
        # Try to open the file with default application
        try:
            if sys.platform == 'win32':
                os.startfile(self.summary_file)
            elif sys.platform == 'darwin':  # macOS
                os.system(f"open '{self.summary_file}'")
            else:  # linux
                os.system(f"xdg-open '{self.summary_file}'")
                
            self.status_var.set(f"Opened {self.summary_file}")
        except Exception as e:
            messagebox.showerror("Error", f"Could not open file: {str(e)}")
            
    def _save_config(self):
        """Save configuration to file."""
        config_dir = Path("config")
        config_dir.mkdir(exist_ok=True)
        
        config_file = config_dir / "game_group_tracker.ini"
        
        try:
            with open(config_file, "w") as f:
                f.write(f"root_folder={self.folder_var.get()}\n")
                f.write(f"theme={ctk.get_appearance_mode()}\n")
                
            self.status_var.set(f"Configuration saved")
        except Exception as e:
            self.status_var.set(f"Error saving config: {str(e)}")
            
    def _load_config(self):
        """Load configuration from file."""
        config_file = Path("config/game_group_tracker.ini")
        
        if config_file.exists():
            try:
                with open(config_file, "r") as f:
                    for line in f:
                        if line.startswith("root_folder="):
                            folder = line.split("=", 1)[1].strip()
                            if os.path.isdir(folder):
                                self.folder_var.set(folder)
                        elif line.startswith("theme="):
                            theme = line.split("=", 1)[1].strip()
                            if theme in ["System", "Light", "Dark"]:
                                ctk.set_appearance_mode(theme)
                                
                self.status_var.set("Configuration loaded")
            except Exception as e:
                self.status_var.set(f"Error loading config: {str(e)}")

# =========================================================================
# ENTRY POINT
# =========================================================================

def main():
    """Main entry point for the application."""
    # Set program name in taskbar
    if sys.platform == 'win32':
        import ctypes
        ctypes.windll.shell32.SetCurrentProcessExplicitAppUserModelID("GameGroupTracker")
    
    # Create and run the app
    app = Dashboard()
    app.mainloop()

if __name__ == "__main__":
    main()
